// SPDX-License-Identifier: MIT
pragma solidity 0.8.2;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

abstract contract ERC721Link is
VRFConsumerBase,
Context,
ERC721URIStorage,
AccessControlEnumerable
{
    using SafeMath for uint256;
    using Strings for uint256;
    using Counters for Counters.Counter;
    Counters.Counter public _tokenIdTracker;
    mapping(bytes32 /* requestId */ => address /* nft owner */) queue;
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    address internal linkAddr;
    address internal vrfCoordinatorAddr;
    bytes32 internal keyHash;
    uint256 internal fee;

    constructor() VRFConsumerBase(
        address(0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B),
        address(0x01BE23585060835E02B77ef475b0Cc51aA1e0709)
    ) {
        // MUMBAI
        // fee = 0.0001 * 10 ** 18;
        // vrfCoordinator = 0x8C7382F9D8f56b33781fE506E897a4F1e2d17255;
        // LINK = LinkTokenInterface(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
        // keyHash = 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4;
        // RINKEBY
        fee = 0.1 ether;
        //      vrfCoordinatorAddr = _msgSender(); // only for tests
        keyHash = 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mintTo(address to) external onlyRole(MINTER_ROLE) {
        _mint(to, _tokenIdTracker.current());
        _tokenIdTracker.increment();
    }

    function _getCurrentTokenindex() public view // dev
    returns (uint256)
    {
        return _tokenIdTracker.current();
    }

    function _mintRandom(uint256 d3Result, address to) internal {
        _mint(to, _tokenIdTracker.current());
        _tokenIdTracker.increment();
        // _setTokenURI(currentTokenIndex, string(abi.encodePacked(d3Result.toString(), "/", currentTokenIndex.toString())));
    }

    function getRandomNumber() public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");
        return requestRandomness(keyHash, fee);
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal
    override (VRFConsumerBase)
    {
        uint256 d3Result = randomness.mod(3);
        _mintRandom(d3Result, queue[requestId]);
        delete queue[requestId];
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(AccessControlEnumerable, ERC721)
    returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    uint256[48] private __gap;
}