// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";

import "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol";
import "@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol";

import "../VRF/VRFConsumerBaseUpgradable.sol";

abstract contract ERC721LinkUpgradeable is Initializable,
        VRFConsumerBaseUpgradable,
        ContextUpgradeable,
        ERC721Upgradeable,
        AccessControlEnumerableUpgradeable
{
    using SafeMathUpgradeable for uint256;
    using CountersUpgradeable for CountersUpgradeable.Counter;
    CountersUpgradeable.Counter public _tokenIdTracker;
    mapping (bytes32 /* requestId */ => address /* nft owner */) queue;
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    event MintRandom(uint256 id, address ownerId, uint256 tokenId);

    address internal linkAddr;
    address internal vrfCoordinatorAddr;
    bytes32 internal keyHash;
    uint256 internal fee;

function __ERC721LinkUpgradeable_init(
    ) public initializer {
        __ERC721LinkUpgradeable_init_unchained();
    }

    function __ERC721LinkUpgradeable_init_unchained() public initializer {
      // MUMBAI
      // fee = 0.0001 * 10 ** 18;
      // vrfCoordinator = 0x8C7382F9D8f56b33781fE506E897a4F1e2d17255;
      // LINK = LinkTokenInterface(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
      // keyHash = 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4;
      // RINKEBY
      fee = 0.1 ether;
      vrfCoordinatorAddr = 0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B;
      linkAddr = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
      keyHash = 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311;

      __VRFConsumerBaseUpgradable_init(vrfCoordinatorAddr, linkAddr);

      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
      _setupRole(MINTER_ROLE, _msgSender());
      _setupRole(PAUSER_ROLE, _msgSender());

    }

    /**
 * @dev Creates a new token for `to`. Its token ID will be automatically
 * assigned (and available on the emitted {IERC721-Transfer} event), and the token
 * URI autogenerated based on the base URI passed at construction.
 *
 * See {ERC721-_mint}.
 *
 * Requirements:
 *
 * - the caller must have the `MINTER_ROLE`.
 */
    function mintTo(address to) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), "Error: must have minter role to mint");
        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        _mint(to, _tokenIdTracker.current());
        _tokenIdTracker.increment();
    }

    function getRandomNumber(uint256 userProvidedSeed) public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");
        return requestRandomness(keyHash, fee, userProvidedSeed);
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal
    override (VRFConsumerBaseUpgradable)
    {
        uint256 d6Result = randomness.mod(6).add(1);
        emit MintRandom(d6Result, queue[requestId], _tokenIdTracker.current());
        mintTo(queue[requestId]);
        delete queue[requestId];
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(AccessControlEnumerableUpgradeable, ERC721Upgradeable)
    returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
    uint256[48] private __gap;
}